# Week5

## speller 2024-11-05

### 心路历程：

11.4早上开始进入题目，读题花了个把小时，然后粗写了些代码，共两小时。此时神清气爽去健身，我并不知道后面debug的艰辛

11.4晚上快7点时我开始坐到教室，一路搞到11点27，汗流浃背，大汗淋漓，汗如雨下，仍有两个问题没有头绪，一个是segmentation fault，另一个是can’t handle max length words(45-char)，时间已近十一点半，我不得不收拾东西回家，此时可谓心如死灰，因为这两个错误我也弄了很久。

11.5下午我来到图书馆，翘掉思政，美美地继续苦干。这一次我看了walkthrough，同时问copilot问题，终于在一个半小时内完成了speller，并且达到了speller50的速度，甚是高兴。

这次week5实在弄了很久，原因是忙于期中考数学的复习，也忙于战队那边的活儿，而speller巨大的阅读量又要求一个连贯的长时段。

现在我想总结回顾一下，同时也记录下我在code时的收获吧。

### 笔记

- 首先是有关文件之间的联动。两个文件同时 #include 一个头文件，这个头文件只包含函数定义，那么编译时这两个代码能够连接起来，所以可以把main函数和自定义函数拆开，从而保持文档的整洁。

> 把代码拆成多个文件通常是个好实践。这样做有助于提高代码的可读性、可维护性和可重用性
> 
- 哈希表
    - 避免碰撞，计算高效是两个重要原则
    - 按位运算的效率很高，而且通常可以等效为某种乘法
    - 当需要case-insensitive的check时，也需要让hash函数不区分大小写，我最后一步就是卡在这里
- 新学习的函数
    - fscanf，可以从文件中读取各种类型的东西
    - fgets，读取一行字符串，并且会将换行读取
    - strcasecmp，不区分大小写地比较字符串，注意 strings.h 和 string.h 不一样
- 反复强调的注意事项
    - fopen需要检查返回的指针，还需要fclose
    - malloc要检查指针是否为NULL，还要free
- 有关链表
    - add要加在头，我昨晚就是想加在尾部，一直写不出正确的代码
- 如果要修改传入的指针

```c
#include <stdio.h>

void modify_value(int *val) {
    *val += 1;
}

int main() {
    int my_val = 10;
    modify_value(&my_val);
    printf("%d\n", my_val);  // 输出: 11
    return 0;
}
```

- 伪代码很重要，我这次是在写了一半才想起来
## inheritance
## Answer

在代码中的这一行 `p = NULL;` 主要是为了避免“悬挂指针”的问题。不过，尽管不设置 `p` 为 `NULL`，程序依然能够正确运行的原因如下：

### 原因分析

1. **递归调用的上下文**：
   - 在 `free_family` 函数的递归调用中，每一次调用都会传入一个新的指针 `p`。每次调用中，`p` 指向当前正在释放的人的内存。如果不设置 `p` 为 `NULL`，这只是影响当前函数调用中的 `p` 变量，并不会影响其他层级的调用。

2. **内存释放的正确性**：
   - 当调用 `free(p);` 时，所指向的内存将被释放。即使 `p` 不被设置为 `NULL`，对 `free_family()` 函数的递归调用将继续进行，并且它们在释放内存时会对各自的 `p` 进行处理。因此，相对更上层的调用，`p` 会继续指向正确的内存地址。

3. **悬挂指针的影响**：
   - 设置 `p` 为 `NULL` 是一个良好的编程习惯，可以避免在后续代码中意外访问已释放的内存。然而，在这个递归函数的最后一层，`p` 不会被用于任何操作，只是用于释放内存，因此不设置为 `NULL` 不会导致程序出错。

### 总结
虽然 `p = NULL;` 可以避免潜在的悬挂指针问题，这是一个好的编程实践，但在这个特殊的递归释放内存的上下文中，它并不是必需的。程序依旧会正确地释放内存，因为每个递归调用中涉及的 `p` 都是独立的，并且它们的生命周期与释放的内存相匹配。
