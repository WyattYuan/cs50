# inheritance
# Answer

在代码中的这一行 `p = NULL;` 主要是为了避免“悬挂指针”的问题。不过，尽管不设置 `p` 为 `NULL`，程序依然能够正确运行的原因如下：

### 原因分析

1. **递归调用的上下文**：
   - 在 `free_family` 函数的递归调用中，每一次调用都会传入一个新的指针 `p`。每次调用中，`p` 指向当前正在释放的人的内存。如果不设置 `p` 为 `NULL`，这只是影响当前函数调用中的 `p` 变量，并不会影响其他层级的调用。

2. **内存释放的正确性**：
   - 当调用 `free(p);` 时，所指向的内存将被释放。即使 `p` 不被设置为 `NULL`，对 `free_family()` 函数的递归调用将继续进行，并且它们在释放内存时会对各自的 `p` 进行处理。因此，相对更上层的调用，`p` 会继续指向正确的内存地址。

3. **悬挂指针的影响**：
   - 设置 `p` 为 `NULL` 是一个良好的编程习惯，可以避免在后续代码中意外访问已释放的内存。然而，在这个递归函数的最后一层，`p` 不会被用于任何操作，只是用于释放内存，因此不设置为 `NULL` 不会导致程序出错。

### 总结
虽然 `p = NULL;` 可以避免潜在的悬挂指针问题，这是一个好的编程实践，但在这个特殊的递归释放内存的上下文中，它并不是必需的。程序依旧会正确地释放内存，因为每个递归调用中涉及的 `p` 都是独立的，并且它们的生命周期与释放的内存相匹配。
